#' Functions for AXE estimates
#'
#' `axe_*()` A list with AXE estimates and time tkaen.
#'
#' @param info Data to use. Varies for each, default is object generated by
#' `prep_*()`
#' @param posteriors Dataframe or list with posterior mean information.
#'  Default is object generated by `pfit_*()`.
#'
#' @return Typically a list, e.g. `eight$axe_yhats` or
#'     `radon_2$axe_yhats`
#'
#' @export
axe_eight <- function(info = eight, posteriors = eight$posteriors) {
  X <- model.matrix(~school,
    data = info$df,
    contrasts.arg =
      list(school = contrasts(info$df$school, contrasts = FALSE))
  )

  loops <- 1:8
  P <- info$df$sd^2

  axe_vals <- purrr::map_df(info$data_scale, function(scl) {
    start <- Sys.time()
    yscale <- info$df$y * scl
    obj <- dplyr::filter(posteriors, data_scale == scl)
    axe <- purrr::map(loops, function(loop) {
      test_mask <- loop == loops

      sigi_diag <- rep(0, ncol(X))
      sigi_diag[2:9] <- 1 / unique(obj$tau_hat)^2
      Sig_inv <- diag(sigi_diag)

      X_t <- X[!test_mask, ]
      P_t <- P[!test_mask]
      V <- solve(t(X_t) %*% diag(1 / P_t) %*% X_t + Sig_inv)
      axe_yhat <- X[test_mask, , drop = FALSE] %*%
        V %*% t(X_t) %*% diag(1 / P_t) %*%
        yscale[!test_mask]

      list(
        idx = which(test_mask),
        axe_yhat = axe_yhat

      )
    })

    end <- Sys.time()
    idx <- do.call("c", purrr::map(axe, ~ .$idx))
    yhat <- do.call("c", purrr::map(axe, ~ .$axe_yhat))
    data.frame(idx = idx, axe_yhat = yhat, data_scale = obj$data_scale,
               time_axe = as.numeric(difftime(end, start, units = "secs")))
  })

  axe_vals
}


axe_ll <- function(siginv, tau2, X, test_mask, Y, keep_test = FALSE) {
  mu <- axe(siginv, tau2, X, test_mask, Y, keep_test = FALSE)
  if (keep_test) {
    X_t <- X
    Y_t <- Y
  } else {
    X_t <- X[!test_mask, ]
    Y_t <- Y[!test_mask]
  }
  V <- axe_v(siginv, tau2, X_t)

  dnorm(Y[test_mask],
    mean = mu,
    sd = sqrt(diag(X[test_mask, , drop = FALSE] %*%
                     V %*% t(X[test_mask, , drop = FALSE]))),
    log = TRUE
  )
}

axe_v <- function(siginv, tau2, X) {
  solve(t(X) %*% X / tau2 + siginv)
}
axe <- function(siginv, tau2, X, test_mask, Y, keep_test = FALSE) {
  if (keep_test) {
    X_t <- X
    Y_t <- Y
  } else {
    X_t <- X[!test_mask, ]
    Y_t <- Y[!test_mask]
  }
  V <- axe_v(siginv, tau2, X_t)
  X[test_mask, , drop = FALSE] %*%
    V %*% t(X_t) %*%
    Y_t / tau2
}

#' @describeIn axe_eight Function for Radon example.
#'
#' @export
axe_radon_full <- function(info = radon_1, posteriors = radon_1$posteriors) {
  dat <- info$data |> dplyr::mutate(
    county = factor(county), floor = factor(floor)
  )
  Xmats <- purrr::map(info$models_axe, function(mod) {
    model.matrix(mod,
      data = dat,
      contrasts = contrasts_for_pooling(dat)
    )
  })
  loops <- unique(dat$county)
  start <- Sys.time()
  axe_vals <- purrr::map_df(posteriors, function(obj) {
    mod_no <- obj$model[1]

    X <- Xmats[[mod_no]]
    sigcols <- stringr::str_detect(colnames(X), "county")

    tau_hat <- obj$tau_hat[1]

    sighat <- obj$sighat[1]
    sigi_diag <- rep(0, ncol(X))
    sigi_diag[sigcols] <- 1 / sighat^2
    Sig_inv <- diag(sigi_diag)

    purrr::map_df(loops, function(loop) {
      test_mask <- loop == dat$county

      axe_yhat <- axe(Sig_inv, tau_hat, X, test_mask, dat$log_radon)

      data.frame(
        i = which(test_mask),
        yhat_axe = axe_yhat,
        model = mod_no,
        loop = loop
      )
      #

    })
  })

  end <- Sys.time()

  list(axe = axe_vals, time = difftime(end, start, units = "secs"))
}


#' @describeIn axe_eight Function for Radon subsets example.
#'
#' @export
axe_radon_simul <- function(info = radon_2, posteriors = radon_2$posteriors,
                            var = c("axe", "iis", "map"), n_cores = 1,
                            seed = 9871) {
  loop_over_radon_simul(
    info = info, seed = seed, n_cores = n_cores,
    export = list("mm_radon", "coeffs_radon", "axe_ll", "axe", "axe_v"),
    expenv = environment(),
    FUN = function(mod_no, dat, n, perc, subset_idx,
                   info, seed, var, posteriors) {
      X <- stats::model.matrix(info$models_axe[[mod_no]],
        data = dat,
        contrasts = contrasts_for_pooling(dat)
      )
      sigcols <- stringr::str_detect(colnames(X), "county")

      dperc <- perc
      vars <- dplyr::filter(
        posteriors, iter == subset_idx, perc == dperc,
        n_clusters == n, model == mod_no
      ) |>
        dplyr::select(tidyselect::contains("sig"),
                      tidyselect::contains("tau")) |>
        unique()



      start_axe <- Sys.time()
      test_mask <- dat$county == info$c_county
      train_mask <- !test_mask
      #

      if (var == "axe") {
        tau2 <- vars$tau2hat_post
        sigma2 <- vars$sig2hat_post
      } else if (var == "iis") {
        sigma2 <- vars$sig2hat_iis_fm
        tau2 <- (vars$tau2hat_iis_fm)
      } else if (var == "map") {
        tau2 <- vars$tau2hat_map
        sigma2 <- vars$sig2hat_map
      }


      sigi_diag <- rep(0, ncol(X))
      sigi_diag[sigcols] <- 1 / sigma2
      Sig_inv <- diag(sigi_diag)


      axe_yhat <- axe(Sig_inv, tau2, X, test_mask, dat$log_radon)


      yhat_post_axe <- axe(Sig_inv, tau2, X, test_mask,
                           dat$log_radon, keep_test = TRUE)


      end_axe <- Sys.time()


      data.frame(
        n_tot = nrow(dat),
        yhat_post_axe = yhat_post_axe,
        yhat_axe = axe_yhat,
        idx = seq_along(axe_yhat)
      ) |>
        dplyr::mutate(
          axe_time = difftime(end_axe, start_axe, units = "secs")
        )
    },
    var = var, posteriors = posteriors
  )
}


#' @describeIn axe_eight Function for Esports player example.
#'
#' @export
axe_lol <- function(info = lol, posteriors = lol$posteriors) {
  loops <- info$loops
  start <- Sys.time()
  P <- posteriors$P

  X <- info$X
  n_player <- length(unique(info$data$player))
  n_champs <- length(unique(info$data$champion))
  siginv <- c(
    rep(0, ncol(X) - n_player - n_champs),
    rep(1 / posteriors$sig_champ, n_champs),
    rep(1 / posteriors$sig_player, n_player)
  )

  eta <- log(posteriors$phats)
  mu <- posteriors$phats
  y_raw <- info$data$kills
  y_working <- eta + (y_raw - mu) / mu
  start <- Sys.time()
  axe <- purrr::map_df(unique(loops), function(loop) {
    test_mask <- loop == loops

    X_t <- X[!test_mask, ]
    P_t <- P[!test_mask]
    V <- solve(t(X_t) %*% diag(1 / P_t) %*% X_t + diag(siginv))
    axe_yhat <- X[test_mask, , drop = FALSE] %*%
      V %*% t(X_t) %*% diag(1 / P_t) %*%
      y_working[!test_mask]

    data.frame(
      idx = which(test_mask),
      yhat_axe = exp(axe_yhat),
      loop = loop
    )
  })

  end <- Sys.time()

  list(df = axe, time = difftime(end, start, units = "secs"))
}

#' @describeIn axe_eight Function for Scottish Lung Cancer example.
#'
#' @export
axe_slc <- function(info = slc$data, posteriors = slc$posteriors) {
  loops <- info$loops
  start <- Sys.time()
  P <- posteriors$P

  X_effs <- diag(rep(1, length(P)))
  X <- cbind(info$X, X_effs)

  D <- diag(rowSums(info$W))

  Siginv <- matrix(0, ncol = ncol(X), nrow = ncol(X))
  sig_idxes <- (ncol(info$X) + 1):ncol(X)
  Siginv[sig_idxes, sig_idxes] <- posteriors$tauhat_post *
    (D - posteriors$alpha_post * info$W)


  eta <- posteriors$muhat
  mu <- exp(eta)
  y_raw <- info$y / exp(info$log_offset)
  y_working <- eta + (y_raw - mu) / mu

  start <- Sys.time()
  axe <- purrr::map_df(unique(loops), function(loop) {
    test_mask <- loop == loops

    X_t <- X[!test_mask, ]
    P_t <- P[!test_mask]
    V <- solve(t(X_t) %*% diag(1 / P_t) %*% X_t + Siginv)
    axe_yhat <- X[test_mask, , drop = FALSE] %*%
      V %*% t(X_t) %*% diag(1 / P_t) %*%
      y_working[!test_mask]

    data.frame(
      idx = which(test_mask),
      yhat_axe = exp(axe_yhat + info$log_offset[test_mask]),
      loop = loop
    )
  })


  end <- Sys.time()

  list(df = axe, time = difftime(end, start, units = "secs"))
}



#' @describeIn axe_eight Function for Scottish Respiratory Disease example.
#'
#' @export
axe_air <- function(info = air$data, posteriors = air$posteriors) {
  loops <- info$loops
  start <- Sys.time()
  P <- posteriors$P
  N <- length(P)
  X_effs <- diag(rep(1, length(P)))
  X <- cbind(info$X, X_effs)

  D <- diag(rowSums(info$W))

  rho_s <- posteriors$rho_s
  rho_t <- posteriors$rho_t
  tau2 <- posteriors$tau2

  # find Sigma^{-1}
  Sigma_inv <- stcarar_sigmainv(rho_s, rho_t, info$W, tau2)

  X <- cbind(info$X, diag(rep(1, N)))

  V <- solve(t(X) %*% diag(1 / P) %*% X + Sigma_inv)

  eta <- as.vector(posteriors$muhat)
  mu <- exp(eta)
  y_raw <- info$df$observed / exp(info$log_offset)
  y_working <- eta + (y_raw - mu) / mu
  # solve for V first
  start <- Sys.time()
  axe <- purrr::map_df(unique(loops), function(loop) {
    test_mask <- loop == loops

    X_t <- X[test_mask, , drop = FALSE]
    P_t <- P[test_mask]
    # since n_t < dim(V) always
    V_t <- V + V %*% t(X_t) %*%
      solve(diag(P_t) - X_t %*% V %*% t(X_t)) %*% (X_t) %*% V
    axe_yhat <- X_t %*%
      V_t %*% t(X[!test_mask, ]) %*% diag(1 / P[!test_mask]) %*%
      y_working[!test_mask]

    data.frame(
      idx = which(test_mask),
      yhat_axe = exp(axe_yhat + info$log_offset[test_mask]),
      loop = loop
    )
  })
  end <- Sys.time()

  list(df = axe, time = difftime(end, start, units = "secs"))
}
