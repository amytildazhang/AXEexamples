#' Functions for AXE estimates
#'
#' `axe_*()` A list with AXE estimates and time tkaen.
#'
#' @param info Data to use. Varies for each, default is object generated by `prep_*()`
#' @param posteriors Dataframe or list with posterior mean information. Default is
#'    object generated by `pfit_*()`.
#'
#' @return Typically a list, e.g. `eight$axe_yhats` or
#'     `radon_2$axe_yhats`
#'
#' @export
axe_eight <- function(info = eight, posteriors = eight$posteriors) {
  X <- model.matrix(~school,
    data = info$df,
    contrasts.arg =
      list(school = contrasts(info$df$school, contrasts = F))
  )

  loops <- 1:8
  start <- Sys.time()
  P <- info$df$sd^2

  axe_vals <- purrr::map(posteriors, function(obj) {
    yscale <- info$df$y * obj$data_scale
    axe <- purrr::map(loops, function(loop) {
      test_mask <- loop == loops

      sigi_diag <- rep(0, ncol(X))
      sigi_diag[2:9] <- 1 / obj$tau_hat^2
      Sig_inv <- diag(sigi_diag)

      X_t <- X[!test_mask, ]
      P_t <- P[!test_mask]
      V <- solve(t(X_t) %*% diag(1 / P_t) %*% X_t + Sig_inv)
      axe_yhat <- X[test_mask, , drop = F] %*%
        V %*% t(X_t) %*% diag(1 / P_t) %*%
        yscale[!test_mask]

      list(
        idx = which(test_mask),
        axe_yhat = axe_yhat
      )
    })


    idx <- do.call("c", purrr::map(axe, ~ .$idx))
    yhat <- do.call("c", purrr::map(axe, ~ .$axe_yhat))
    list(idx = idx, axe_yhat = yhat, data_scale = obj$data_scale)
  })

  end <- Sys.time()
  end - start

  list(axe = axe_vals, time = difftime(end, start, units = "secs"))
}


axe_ll <- function(siginv, tau2, X, test_mask, Y, keep_test = F) {
  mu <- axe(siginv, tau2, X, test_mask, Y, keep_test = F)
  if (keep_test) {
    X_t <- X
    Y_t <- Y
  } else {
    X_t <- X[!test_mask, ]
    Y_t <- Y[!test_mask]
  }
  V <- axe_v(siginv, tau2, X_t)

  dnorm(Y[test_mask],
    mean = mu,
    sd = sqrt(diag(X[test_mask, , drop = F] %*% V %*% t(X[test_mask, , drop = F]))),
    log = T
  )
}

axe_v <- function(siginv, tau2, X) {
  solve(t(X) %*% X / tau2 + siginv)
}
axe <- function(siginv, tau2, X, test_mask, Y, keep_test = F) {
  if (keep_test) {
    X_t <- X
    Y_t <- Y
  } else {
    X_t <- X[!test_mask, ]
    Y_t <- Y[!test_mask]
  }
  V <- axe_v(siginv, tau2, X_t)
  X[test_mask, , drop = F] %*%
    V %*% t(X_t) %*%
    Y_t / tau2
}

#' @describeIn axe_eight Function for Radon example.
#'
#' @export
axe_radon_full <- function(info = radon_1, posteriors = radon_1$posteriors) {
  dat <- info$data %>% dplyr::mutate(
    county = factor(county), floor = factor(floor)
  )
  Xmats <- purrr::map(info$models_axe, function(mod) {
    model.matrix(mod,
      data = dat,
      contrasts = contrasts_for_pooling(dat)
    )
  })
  loops <- unique(dat$county)
  start <- Sys.time()
  axe_vals <- purrr::map_df(posteriors, function(obj) {
    mod_no <- obj$model[1]

    X <- Xmats[[mod_no]]
    sigcols <- stringr::str_detect(colnames(X), "county")
    purrr::map_df(loops, function(loop) {
      test_mask <- loop == dat$county
      vars <- obj[obj$loop == loop, ] %>%
        dplyr::select(tau_hat) %>%
        unique()
      tau_hat <- vars$tau_hat[1] # sighat2 <- vars$sighat_iis_c[1]


      sighat <- obj$sighat[1]


      sigi_diag <- rep(0, ncol(X))
      sigi_diag[sigcols] <- 1 / sighat^2
      Sig_inv <- diag(sigi_diag)

      axe_yhat <- axe(Sig_inv, tau_hat, X, test_mask, dat$log_radon)

      # using IIS-C estimate for sigma
      #  sigi_diag[sigcols] <- 1/sighat2
      #  Sig_inv2 <- diag(sigi_diag)
      #  tauhat <- sqrt(vars$tauhat_iis_c[1])
      # axe_yhat_iis <-axe(Sig_inv2, tauhat, X, test_mask, dat$log_radon)
      #

      # tau_map <- vars$tau_map; sig2_map <- vars$sig2_map;
      # # using MAP variance estimates
      # sigi_diag[sigcols] <- 1/sig2_map
      # Sig_inv2 <- diag(sigi_diag)
      # tauhat <- (vars$tau_map[1])
      # axe_yhat_map <-axe(Sig_inv2, tauhat, X, test_mask, dat$log_radon)
      #



      # purrr::map(unique(loops), function(loop) {
      #     train_mask <- loop != loops
      #     score_dtm(Y[train_mask], X[train_mask, ], SigmaInv, tau, P, dsprior, dtprior)
      #
      # }) %>% purrr
      data.frame(
        i = which(test_mask),
        yhat_axe = axe_yhat,
        # yhat_axe_iis = axe_yhat_iis,
        # yhat_axe_map = axe_yhat_map,
        model = mod_no
      )
    })
  })

  end <- Sys.time()

  list(axe = axe_vals, time = difftime(end, start, units = "secs"))
}


#' @describeIn axe_eight Function for Radon subsets example.
#'
#' @export
axe_radon_simul <- function(info = radon_2, posteriors = radon_2$posteriors,
                            var = c("axe", "iis", "map"), n_cores = 1, seed = 9871) {
  loop_over_radon_simul(
    info = info, seed = seed, n_cores = n_cores,
    export = list("mm_radon", "coeffs_radon", "axe_ll", "axe", "axe_v"),
    expenv = environment(),
    FUN = function(mod_no, dat, n, perc, subset_idx, info, seed, var, posteriors) {
      X <- stats::model.matrix(info$models_axe[[mod_no]],
        data = dat,
        contrasts = contrasts_for_pooling(dat)
      )
      sigcols <- stringr::str_detect(colnames(X), "county")

      dperc <- perc
      vars <- dplyr::filter(
        posteriors, iter == subset_idx, perc == dperc,
        n_clusters == n, model == mod_no
      ) %>%
        dplyr::select(tidyselect::contains("sig"), tidyselect::contains("tau")) %>%
        unique()



      start_axe <- Sys.time()
      test_mask <- dat$county == info$c_county
      train_mask <- !test_mask
      #

      if (var == "axe") {
        tau2 <- vars$tau2hat_post
        sigma2 <- vars$sig2hat_post
      } else if (var == "iis") {
        sigma2 <- vars$sig2hat_iis_fm
        tau2 <- (vars$tau2hat_iis_fm)
      } else if (var == "map") {
        tau2 <- vars$tau2hat_map
        sigma2 <- vars$sig2hat_map
      }


      sigi_diag <- rep(0, ncol(X))
      sigi_diag[sigcols] <- 1 / sigma2
      Sig_inv <- diag(sigi_diag)


      axe_yhat <- axe(Sig_inv, tau2, X, test_mask, dat$log_radon)


      yhat_post_axe <- axe(Sig_inv, tau2, X, test_mask, dat$log_radon, keep_test = T)


      end_axe <- Sys.time()


      data.frame(
        n_tot = nrow(dat),
        yhat_post_axe = yhat_post_axe,
        yhat_axe = axe_yhat,
        idx = 1:length(axe_yhat)
      ) %>%
        dplyr::mutate(
          axe_time = difftime(end_axe, start_axe, units = "secs")
        )
    },
    var = var, posteriors = posteriors
  )
}


#' @describeIn axe_eight Function for Esports player example.
#'
#' @export
axe_lol <- function(info = lol, posteriors = lol$posteriors) {
  loops <- info$loops
  start <- Sys.time()
  P <- posteriors$P
  y <- log(posteriors$phats)

  X <- info$X
  n_player <- length(unique(info$data$player))
  n_champs <- length(unique(info$data$champion))
  siginv <- c(
    rep(0, ncol(X) - n_player - n_champs),
    rep(1 / posteriors$sig_champ, n_champs),
    rep(1 / posteriors$sig_player, n_player)
  )

  start <- Sys.time()
  axe <- purrr::map_df(unique(loops), function(loop) {
    test_mask <- loop == loops

    X_t <- X[!test_mask, ]
    P_t <- P[!test_mask]
    V <- solve(t(X_t) %*% diag(1 / P_t) %*% X_t + diag(siginv))
    axe_yhat <- X[test_mask, , drop = F] %*%
      V %*% t(X_t) %*% diag(1 / P_t) %*%
      y[!test_mask]

    data.frame(
      idx = which(test_mask),
      yhat_axe = exp(axe_yhat),
      loop = loop
    )
  })

  end <- Sys.time()

  list(df = axe, time = difftime(end, start, units = "secs"))
}

#' @describeIn axe_eight Function for Scottish Lung Cancer example.
#'
#' @export
axe_slc <- function(info = slc$data, posteriors = slc$posteriors) {
  loops <- info$loops
  start <- Sys.time()
  P <- posteriors$P

  y <- posteriors$muhat
  # y <- log(info$y + 1e-8) - info$log_offset
  # y <- 1/P
  X_effs <- diag(rep(1, length(y)))
  X <- cbind(info$X, X_effs)

  D <- diag(rowSums(info$W))

  Siginv <- matrix(0, ncol = ncol(X), nrow = ncol(X))
  sig_idxes <- (ncol(info$X) + 1):ncol(X)
  Siginv[sig_idxes, sig_idxes] <- posteriors$tauhat_post * (D - posteriors$alpha_post * info$W)



  start <- Sys.time()
  axe <- purrr::map_df(unique(loops), function(loop) {
    test_mask <- loop == loops

    X_t <- X[!test_mask, ]
    P_t <- P[!test_mask]
    V <- solve(t(X_t) %*% diag(1 / P_t) %*% X_t + Siginv)
    axe_yhat <- X[test_mask, , drop = F] %*%
      V %*% t(X_t) %*% diag(1 / P_t) %*%
      y[!test_mask]

    data.frame(
      idx = which(test_mask),
      yhat_axe = exp(axe_yhat + info$log_offset[test_mask]),
      loop = loop
    )
  })


  end <- Sys.time()

  list(df = axe, time = difftime(end, start, units = "secs"))
}



#' @describeIn axe_eight Function for Scottish Respiratory Disease example.
#'
#' @export
axe_air <- function(info = air$data, posteriors = air$posteriors) {
  loops <- info$loops
  start <- Sys.time()
  P <- posteriors$P
  N <- length(P)
  y <- posteriors$muhat
  # y <- 1/P
  X_effs <- diag(rep(1, length(y)))
  X <- cbind(info$X, X_effs)

  D <- diag(rowSums(info$W))

  rho_s <- posteriors$rho_s
  rho_t <- posteriors$rho_t
  tau2 <- posteriors$tau2

  # find Sigma^{-1}

  Sigma_inv <- stcarar_sigmainv(rho_s, rho_t, info$W, tau2)

  X <- cbind(info$X, diag(rep(1, N)))

  V <- solve(t(X) %*% diag(1 / P) %*% X + Sigma_inv)

  # solve for V first
  start <- Sys.time()
  axe <- purrr::map_df(unique(loops), function(loop) {
    test_mask <- loop == loops

    X_t <- X[test_mask, , drop = F]
    P_t <- P[test_mask]
    # since n_t < dim(V) always

    # V_t <- solve(t(X[!test_mask, ]) %*% diag(1/P[!test_mask]) %*% X[!test_mask, ] + Sigma_inv)
    V_t <- V + V %*% t(X_t) %*% solve(diag(P_t) - X_t %*% V %*% t(X_t)) %*% (X_t) %*% V
    axe_yhat <- X_t %*%
      V_t %*% t(X[!test_mask, ]) %*% diag(1 / P[!test_mask]) %*%
      y[!test_mask]

    data.frame(
      idx = which(test_mask),
      yhat_axe = exp(axe_yhat + info$log_offset[test_mask]),
      loop = loop
    )
  })
  end <- Sys.time()

  list(df = axe, time = difftime(end, start, units = "secs"))
}
